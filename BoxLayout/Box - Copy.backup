using System;
using System.Collections.Generic;
using System.Linq;

namespace Boxing
{
    abstract public class Box : BoxBase
    {
        public Box (Orientation orientation) : base (orientation)
        {
        }

        public void DoAlignCross ()
        {
            // Store Line cross layout height.
            if (Wrap == true && Children.Count > 1)
                AlignCrossLines ();
            else
                AlignCrossLine (Children);
        }

        public void AlignCrossLines ()
        {

        }

        public void AlignCrossLine (List<Box> children)
        {
            Point point = Point.New (Orientation);
            int crossLength = children.Max (c => c.LayoutSize.GetCross (Orientation));
            Position.AlignCross (this, children, point, crossLength);
        }
        
        public void Layout (int width, int height)
        {
            Layout (0, 0, width, height);
        }

        public void Layout (int x, int y, int width, int height)
        {
            Size used;

            // Make sure layout size has been limited to UserMaxSize by the caller.
            // If it hasn't then it's an error by the caller and we'll limit ourselves.
            width = Math.Min (width, UserMaxSize.Width);
            height = Math.Min (height, UserMaxSize.Height);

            if (Children.Count == 0)
            {
                used = Size.New (0, 0, Orientation);
            }
            else
            {
                Size size = Size.New (width, height, Orientation);

                // Get used cross size given all layout size.
                used = LayoutPass (size);

                // Re-layout with used cross size, if it's less then layout size
                if (used.Cross < size.Cross)
                {
                    // And there's no child that expands cross-wise.
                    if (Children.All (b => b.Expand.GetCross (Orientation)) == false)
                    {
                        size.Cross = used.Cross;
                        used = LayoutPass (size);
                    }
                }
            }
            LayoutPosition = Point.New (x, y, Orientation);
            LayoutSize = Size.New (width, height, Orientation);
            // Make sure actual size isn't smaller than UserMinSize.
            ActualSize.Main = Math.Max (used.Main, UserMinSize.Main);
            ActualSize.Cross = Math.Max (used.Cross, UserMinSize.Cross);
        }

        protected Size LayoutPass (Size max)
        {
            if (Wrap)
                Lines = WrapAlgorithm.GetLines (Orientation, Children, max.Main);
            else
                Lines = WrapAlgorithm.GetLine (Orientation, Children);

            Dictionary<Line, int> minimumCross = new Dictionary<Line, int> ();
            Dictionary<Line, int> finalCross = new Dictionary<Line, int> ();

            Point position = Point.New (Orientation);

            // Layout with no cross length to find minimum used cross length for each line.
            Size min = Size.New (max.Width, max.Height, Orientation);
            Lines.ForEach (line => {
                min.Cross = line.MinSize.Cross;
                minimumCross[line] = LayoutLine (position, min, line.Children, line.MinSize).Cross;
                // For lines that cannot expand, this would also be their final cross length.
                if (line.Expand.GetCross (Orientation) == false)
                    finalCross[line] = minimumCross[line];
            });

            // Find lines that can expand cross wise.
            List<Line> expandingLines = Lines.Where (line => line.Expand.GetCross (Orientation)).ToList ();

            while (expandingLines.Count != 0)
            {
                // Find minimum cross lengths for expanding lines.
                int expandingMinCross = expandingLines.Sum (e => minimumCross[e]);
                // Calculate available cross length.
                int availableCross = max.Cross - finalCross.Sum (pair => pair.Value);

                Spacing spacing = Spacing.New (expandingLines.Count, expandingMinCross, availableCross);

                // Set spacing
                expandingLines.ForEach (line => finalCross[line] = minimumCross[line] + spacing.Next ());

                // Find lines that hits UserMaxSize and expanded too much.
                List<Line> hitUserMax = expandingLines.Where (line => finalCross[line] >= line.UserMaxSize.Cross).ToList ();

                if (hitUserMax.Count > 0)
                {
                    // Correct the finalCross length for lines.
                    hitUserMax.ForEach (line => finalCross[line] = line.UserMaxSize.Cross);
                    // Remove them from the expandingLines list and re-run the loop if necessary.
                    expandingLines = expandingLines.Except (hitUserMax).ToList ();
                    // Reset expandingLines final cross length.
                    expandingLines.ForEach (line => finalCross[line] = 0);
                }
                else
                {
                    // If no line hit UserMax, then they've expanded as much as possible and we're done.
                    expandingLines.Clear ();
                }
            }

            // Layout with final cross lengths.
            Size total = Size.New (Orientation);

            Lines.ForEach (line => {
                Size lineSize = Size.New (Orientation);
                lineSize.Main = max.Main;
                lineSize.Cross = finalCross[line];

                position.Main = 0;
                position.Cross = total.Cross;

                Size used = LayoutLine (position, lineSize, line.Children, line.MinSize);

                total.Main = Math.Max (total.Main, used.Main);
                total.Cross += lineSize.Cross;
            });

            return total;
        }


        protected Size LayoutLine (Point position,
                                   Size lineSize,
                                   List<Box> children,
                                   Size childrenMinSize)
        {
            Point offset = Point.New (Orientation);
            Point point = Point.New (Orientation);
            Size usedTotal = Size.New (Orientation);
            Size size = Size.New (Orientation);

            Compute.MainLengths (Orientation, children, lineSize.Main);

            for (int i = 0; i < children.Count; i++)
            {
                Box child = children[i];

                point.Main = position.Main + offset.Main;
                point.Cross = position.Cross;
                size.Main = child.Computed.MainLength;
                size.Cross = Math.Max (lineSize.Cross, childrenMinSize.Cross);

                child.Layout (point.X, point.Y, size.Width, size.Height);

                // Cross size is largest minimum for all children on this line, but it shouldn't be used unless cross expand is true.
                if (child.Expand.GetCross (Orientation) == false &&
                    child.ActualSize.GetCross (Orientation) < child.LayoutSize.GetCross (Orientation))
                {
                    size.Main = child.Computed.MainLength;
                    size.Cross = child.ActualSize.GetCross (Orientation);
                    child.Layout (point.X, point.Y, size.Width, size.Height);
                }

                if (child.ActualSize.GetMain (Orientation) > child.LayoutSize.GetMain (Orientation))
                    usedTotal.Main += child.LayoutSize.GetMain (Orientation);
                else
                    usedTotal.Main += child.ActualSize.GetMain (Orientation);

                if (child.ActualSize.GetCross (Orientation) > child.LayoutSize.GetCross (Orientation))
                    usedTotal.Cross = Math.Max (usedTotal.Cross, child.LayoutSize.GetCross (Orientation));
                else
                    usedTotal.Cross = Math.Max (usedTotal.Cross, child.ActualSize.GetCross (Orientation));
                offset.Main += size.Main;
            }
            // Move this to Layout
            Position.AlignMain (this, children, lineSize.Main);
            return usedTotal;
        }
    }
}